# the original libsvm.jar has svm_predict modified to output result.txt which denotes the scoring of the set
if [ "$1" = 'm' ] || [ "$1" = 'meta' ]
then
	java -jar Lib/meta.jar ${2:-4}
fi
if [ "$1" = 's' ] || [ "$1" = 'sel' ]
then
	# note that $# = sel + 1 ('s' takes up one var)
	SEL=${*##"sel"}
	SEL=${SEL##"s"}
fi
# it seems that the result.txt file generated by libsvm.jar sometimes goes wrong????
# the reason is that libsvm does not remove the original result.txt, it just append to it, so that this will cost the first result to be huge
# this line guarantees that the result.txt can be generated correctly!! since that result.txt is not the standard output file, and is generated by modifying the sources
SEL=${SEL:-"1 2 3"}
#SEL=${SEL:-"1 2 3 4 5"}
rm result.txt
#find . -regex '.*result.\.txt' | xargs rm
for ((i=0; i<10; i++))
do
	./select.py data$i.txt $SEL > data_sel$i.txt
	./select.py test$i.txt $SEL > test_sel$i.txt
	#java -classpath Lib/libsvm.original.jar svm_train  -g 3 -t 2 -b 1 data_sel$i.txt > tmp
	java -classpath Lib/libsvm.original.jar svm_train -g 6 -t 2 -b 1 data_sel$i.txt > tmp
	#java -classpath Lib/libsvm.original.jar svm_train -g $1 -t 2 -b 1 data$i.txt > tmp
	# why can't I generate result$i.txt files??
	# seems that the output file does not have influence
	# have put o.txt more arguements here!!!!
	java -classpath Lib/libsvm.original.jar svm_predict -b 1 test_sel$i.txt data_sel$i.txt.model o.txt > tmp
	rm data_sel$i.txt.model
	#rm data$i.txt
	#rm "test$i.txt"
	cat o.txt | awk 'NR>1 {printf("%g\n", $2)}' > result$i.txt
done

#java -jar Lib/ResultsList.jar

rm intres.txt
for ((i=0; i<10; i++))
do
   cat result$i.txt >> intres.txt
   rm result$i.txt
done

paste -d ' ' 'intres.txt' 'record.txt' > result.txt

java -jar Lib/auc.jar result.txt list > list.txt

#rm result.txt
echo 'Ensemble'$SEL':'
tail -n 2 list.txt

#./ada_eva.sh
./single_eva.sh 3
